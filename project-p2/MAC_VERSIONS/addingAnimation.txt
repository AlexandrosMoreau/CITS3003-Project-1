
A) Changes required for the GLSL vertex shader:

Add the following variables to your vertex shader:

    attribute vec4 boneIDs;
    attribute vec4 boneWeights;
    uniform mat4 boneTransforms[64];

At the start of main() in the vertex shader, you need to calculate the
bone transformation for the current vertex by taking the weighted sum
of the current bone transformations for the 4 bone-IDs, using the
given bone-weights.  (Note, some weights may be zero, but this
shouldn't affect your code.)

E.g., you might have GLSL code that looks like the following:

    mat4 boneTransform = boneWeights[0] * boneTransforms[boneIDs[0]] +
                         boneWeights[1] * boneTransforms[boneIDs[1]] +
                         ...

Since we have boneIDs declared as vec4 (equivalent to float[4]) rather
than ivec4 (equivalent to int[4]), we need to do a type
conversion. You will need to modify the code above to something like:

    mat4 boneTransform = boneWeights[0] * boneTransforms[int(boneIDs[0])] +
                         boneWeights[1] * boneTransforms[int(boneIDs[1])] +
                         ...

The boneTransform matrix should then be used to transform both the
vertex position and vertex normal.


Note that we can't do type casting like (int)(boneIDs[0]) in shaders;
instead, we have to call the 'int' constructor. An alternative is to
convert the boneIDs to ivec4 type (by calling the ivec4 constructor)
first:

    ivec4 bone = ivec4(boneIDs); // convert boneIDs to ivec4
    mat4 boneTransform = boneWeights[0] * boneTransforms[bone[0]] +
                         boneWeights[1] * boneTransforms[bone[1]] +
                         ...
    
In the rest of the vertex shader, use the transformed vertex position
and vertex normal instead of the original one.

----------------------------------------------------------------------

B) Changes required for the C++ code:

1) In gnatidread.h, you need to increase the number of meshes by 2 to 58
(or larger) by replacing
    const int numMeshes = 56;
with
    const int numMeshes = 58;

model56.x is the monkey head. So if you have two articulated models
(model57.x and model58.x), then numMeshes should be 59 (models are
numbered from 0 onward).

If you have more articulated models created, then change the value of
numMeshes accordingly.


2) You also need to add appropriate entries at the end of the
initialisation of objectMenuEntries for your articulated model(s) and
the test animation (of a monkey head) available at:

   http://undergraduate.csse.uwa.edu.au/units/CITS3003/laboratories/project-common/model56.x


Download the following file and place it in your source code directory: 
    http://undergraduate.csse.uwa.edu.au/units/CITS3003/laboratories/project-common/gnatidread2.h

Then, in your main C++ file, after the line 
    #include "gnatidread.h"
add
    #include "gnatidread2.h"


3) Add global GLuint variables vBoneIDs, vBoneWeights and uBoneTransforms
for the locations of the vertex shader variables added in part A.
(Similar to the existing vPosition, projectionU, etc.)

Initialise these in the init function like the other shader variable locations.
(I.e., via glGetAttribLocation/glGetUniformLocation.)


4) Add the following after the declaration of the meshes array near
the start of the code.  This array stores extra "scene" related
information for each loaded mesh, including the bone transformations
for the keyframes of animations.

   const aiScene* scenes[numMeshes];


5) Replace the lines in loadMeshIfNotAlreadyLoaded that load a mesh
into the meshes array:

    aiMesh* mesh = loadMesh(meshNumber);
    meshes[meshNumber] = mesh;

with code like the following which also stores the scene for the mesh:

    const aiScene* scene = loadScene(meshNumber);
    scenes[meshNumber] = scene;
    aiMesh* mesh = scene->mMeshes[0];
    meshes[meshNumber] = mesh;;



6) Add code like the following to the end of loadMeshIfNotAlreadyLoaded
to initialise the new vertex shader "in"-variables/vertex-attributes
via initBones (in gnatidread2.h):

    //**************
    // Get boneIDs and boneWeights for each vertex from the imported mesh data
    GLint boneIDs[mesh->mNumVertices][4];
    GLfloat boneWeights[mesh->mNumVertices][4];
    getBonesAffectingEachVertex(mesh, boneIDs, boneWeights);

    GLuint buffers[2];
    glGenBuffers( 2, buffers );  // Add two vertex buffer objects
    
    glBindBuffer( GL_ARRAY_BUFFER, buffers[0] ); CheckError();
    glBufferData( GL_ARRAY_BUFFER, sizeof(int)*4*mesh->mNumVertices, boneIDs, GL_STATIC_DRAW ); CheckError();
    glVertexAttribPointer(vBoneIDs, 4, GL_INT, GL_FALSE, 0, BUFFER_OFFSET(0)); CheckError();
    glEnableVertexAttribArray(vBoneIDs);     CheckError();
    
    glBindBuffer( GL_ARRAY_BUFFER, buffers[1] );
    glBufferData( GL_ARRAY_BUFFER, sizeof(float)*4*mesh->mNumVertices, boneWeights, GL_STATIC_DRAW );
    glVertexAttribPointer(vBoneWeights, 4, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
    glEnableVertexAttribArray(vBoneWeights);    CheckError();
    //**************



7a) (see 7b below if part 7a here does not work on Linux) Add code
like following to the drawMesh function to set the new uniform
shader variable boneTransforms each time a mesh is drawn.

(This needs to be after the call to loadMeshIfNotAlreadyLoaded and
before the call to glDrawElements.)

    //*************
    int nBones = meshes[sceneObj.meshId]->mNumBones;
    if(nBones == 0)
        // If no bones, just a single identity matrix is used
        nBones = 1;

    // get boneTransforms for the first (0th) animation at the given
    // time (a float measured in frames)
    // (Replace <POSE_TIME> appropriately with a float expression
    // giving the time relative to the start of the animation,
    // measured in frames, like the frame numbers in Blender.)

    mat4 boneTransforms[nBones];     // was: mat4 boneTransforms[mesh->mNumBones];
    calculateAnimPose(meshes[sceneObj.meshId], scenes[sceneObj.meshId], 0,
                      <POSE_TIME>, boneTransforms);
    glUniformMatrix4fv(uBoneTransforms, nBones, GL_TRUE,
                      (const GLfloat *)boneTransforms);
    //**************

7b. Follow the instruction given in part 7a above. If the g++ compiler does not
allow you to declare an array of dynamic length, then you would need to replace the
line:

    mat4 boneTransforms[nBones];     // was: mat4 boneTransforms[mesh->mNumBones];

by the following lines:

    mat4 *boneTransforms;
    boneTransforms = (mat4 *)malloc(sizeof(mat4)*nBones);
    // initialize each boneTransforms[i] to a zero matrix
    for (int i=0; i < nBones; i++)
        boneTransforms[i] = mat4(0.0);

That is, instead of requesting enough space for the variable boneTransforms
on the stack, we call malloc to allocate enough memory for it on the heap.
The 'for' loop that initializes each boneTransforms[i] to a zero matrix can
be omitted, as this should be the default.

